import React from "react";
/*
A function is a pattern for the local evolution of a computational process. 
It specifies how each stage of the process is built upon the previous stage. 
We would like to be able to make statements about the overall, or global, behavior of a process whose local evolution has been specified by a function. 
This is very difficult to do in general, but we can at least try to describe some typical patterns of process evolution.

In this section we will examine some common shapes for processes generated by simple functions.
We will also investigate the rates at which these processes consume the important computational resources of time and space. 
The functions we will consider are very simple. 
Their role is like that played by test patterns in photography: as oversimplified prototypical patterns, rather than practical examples in their own right.
*/

/*
We begin by considering the factorial function, defined by:
ùëõ!=ùëõ‚ãÖ(ùëõ‚àí1)‚ãÖ(ùëõ‚àí2)‚ãØ3‚ãÖ2‚ãÖ1
There are many ways to compute factorials. One way is to make use of the observation that ùëõ! is equal to ùëõ times (ùëõ‚àí1)! for any positive integer ùëõ:
ùëõ!=ùëõ‚ãÖ[(ùëõ‚àí1)‚ãÖ(ùëõ‚àí2)‚ãØ3‚ãÖ2‚ãÖ1]=ùëõ‚ãÖ(ùëõ‚àí1)!
Thus, we can compute ùëõ! by computing (ùëõ‚àí1)! and multiplying the result by ùëõ. 
If we add the stipulation that 1! is equal to 1, this observation translates directly into a function:
*/
function factorial(n) {
  return n === 1 ? 1 : n * factorial(n - 1);
  /*
  The linear recursive process for computing factorial(6)
  factorial(6)
  6 * factorial(5)
  6 *(5 * factorial(4))
  6 *(5 *(4 * factorial(3)))
  6 *(5 *(4 *(3 * factorial(2))))
  6 *(5 *(4 *(3 * (2 * factorial(1)))))
  6 *(5 *(4 *(3 * (2 * 1)))))
  6 *(5 *(4 *(3 * 2)))
  6 *(5 *(4 * 6))
  6 *(5 * 24)
  6 * 120
  720
  The expansion occurs as the process builds up a chain of deferred operations (in this case, a chain of multiplications). 
  The contraction occurs as the operations are actually performed.
  This type of process, characterized by a chain of deferred operations, is called a recursive process. 
  Carrying out this process requires that the interpreter keep track of the operations to be performed later on. 
  In the computation of ùëõ!, the length of the chain of deferred multiplications, and hence the amount of information needed to keep track of it, grows linearly with ùëõ (is proportional to ùëõ), just like the number of steps. 
  Such a process is called a linear recursive process.
  */
}

//Now let's take a different perspective on computing factorials.
//the counter and the product simultaneously change from one step to the next according to the rule:
// product ‚Üê counter ‚ãÖ product
// counter ‚Üê counter + 1
function iterativeFactorial(n) {
  return factIter(1, 1, n);
}
function factIter(product, counter, maxCount) {
  return counter > maxCount
    ? product
    : factIter(counter * product, counter + 1, maxCount);
  /*
  A linear iterative process for computing iterativeFactorial(6)
  iterativeFactorial(6)
  factIter(1,1,6)
  factIter(1,2,6)
  factIter(2,3,6)
  factIter(6,4,6)
  factIter(24,5,6)
  factIter(120,6,6)
  factIter(720,7,6)
  720
  At each step, all we need to keep track of, for any ùëõ, are the current values of the names product, counter, and max_count. 
  We call this an iterative process. 
  In general, an iterative process is one whose state can be summarized by the values of a fixed number of state names, together with a fixed rule that describes how the values of the state names should be updated as the process moves from state to state and an (optional) end test that specifies conditions under which the process should terminate. In computing ùëõ!, the number of steps required grows linearly with ùëõ. 
  Such a process is called a linear iterative process.
  */
}

/*
The contrast between the factorial and iterativeFactorial can be seen in another way.
In the iterative case, the values of the program names provide a complete description of the state of the process at any point. 
If we stopped the computation between steps, all we would need to do to resume the computation is to supply the interpreter with the values of the three program names. 
Not so with the recursive process. 
In this case there is some additional hidden information, maintained by the interpreter and not contained in the program names, which indicates where the process is in negotiating the chain of deferred operations. 
The longer the chain, the more information must be maintained.
*/
function ex19() {
  /*
    Each of the following two functions defines a method for adding two positive integers in terms of the functions inc, which increments its argument by 1, and dec, which decrements its argument by 1.
    Using the substitution model, illustrate the process generated by each function in evaluating plus(4,5);. Are these processes iterative or recursive?
 */
  function inc(a) {
    return a + 1;
  }
  function dec(a) {
    return a - 1;
  }
  //The process generated by the first procedure is recursive.

  function plus1(a, b) {
    return a === 0 ? b : inc(plus1(dec(a), b));
  }
  /*
  plus(4, 5)
  4 === 0 ? 5 : inc(plus(dec(4), 5))
  inc(plus(dec(4), 5))
  ...
  inc(plus(3, 5))
  ...
  inc(inc(plus(2, 5)))
  ...
  inc(inc(inc(plus(1, 5))))
  ...
  inc(inc(inc(inc(plus(0, 5)))))
  inc(inc(inc(inc( 0 === 0 ? 5 : inc(plus(dec(0), 5))))))
  inc(inc(inc(inc( 5 ))))
  inc(inc(inc( 6 )))
  inc(inc( 7 ))
  inc( 8 )
  9
  */
  //The process generated by the second procedure is iterative.
  function plus2(a, b) {
    return a === 0 ? b : plus2(dec(a), inc(b));
  }
  /*
  plus(4, 5)
  4 === 0 ? 5 : plus(dec(4), inc(5))
  plus(dec(4), inc(5))
  ...
  plus(3, 6)
  ...
  plus(2, 7)
  ...
  plus(1, 8)
  ...
  plus(0, 9)
  0 === 0 ? 9 : plus(dec(0), inc(9))
  9
  */
  return [plus1, plus2];
}
const [plus1, plus2] = ex19();

function ex110() {
  function Ackermann(x, y) {
    return y === 0
      ? 0
      : x === 0
      ? 2 * y
      : y === 1
      ? 2
      : Ackermann(x - 1, Ackermann(x, y - 1));
  }

  const [a, b, c] = [Ackermann(1, 10), Ackermann(2, 4), Ackermann(3, 3)];
  function f(n) {
    return Ackermann(0, n);
  }
  function g(n) {
    return Ackermann(1, n);
  }
  function h(n) {
    return Ackermann(2, n);
  }
  function k(n) {
    return 5 * n * n;
  }
  return [a, b, c, f, g, h, k];
}

const [a, b, c, f, g, h, k] = ex110();

export function functionsAndTheProcessesTheyGenerate() {
  return (
    <div>
      functionsAndTheProcessesTheyGenerate
      <div>{factorial(6)}</div>
      <div>{iterativeFactorial(6)}</div>
      <div>{plus1(4, 4)}</div>
      <div>{plus2(4, 4)}</div>
      <div>
        {a} {b} {c}
      </div>
      <div>
        {f(4)} {g(4)} {h(4)} {k(4)}
      </div>
      <div>{}</div>
      <div>{}</div>
      <div>{}</div>
    </div>
  );
}
